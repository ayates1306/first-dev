/**

The idea is that the messages themselves are defined in a global message file.
Since the signature is key:variant the variant needs to be defined/typed too.

Note that if this message definition is global then the rules manager
can use the value type to perform more complex operations on them rather
than just forwarding the payload.

Definition:
typedef struct {
char*key;
void*value;
} kvpair;

char* domain
char* message
Essentially the array of {string, variant} maps is a variable number of args
Where each arg is a key and the value is a typed thing
int num args
kvpair[0]

Need some markup which can have void* types

YAML
Complex types are defined with ?
? |
  This is a key
  that has multiple lines
: [2001-01-01, 2002-02-02 ]

Sequences, like lists or arrays
A_sequence:
 - Item 1
 - Item 2
 - 0.5 # Note disparate type inside sequence; This seems to be useful for my sequence of variants
 - Item 4
 - Key : value
   another_key : another_value
 -
   - This is a sequence
   - inside another sequence

!!str to state it's a string
---------------------------------------------
JSON
json_map: { "key" : "value" }
json_seq: [3,2,1,"takeoff"]
	  

---------------------------------------------
Basic messages:

Domain: LED
message:"start_pattern"
key:"pattern"
value:"string"  -- not an int??



Domain:Bluetooth


Domain:WiFi


Domain:Audio
message:


Can we use Doxygen groups to collect the message names and key/value pairs?
Since the payload is an array of key/variants does this prevent us doing anything?
Is Rules Manager #1 bound to assume only strings as the variant type?
Rules Manager should be able to check for the presence of 1 or more explicit keys with or without explicit values.

-------------------------------
The test team want a list of supported messages
and their payloads. But the payloads are really just key/values so the 
definition cannot state every permutation, just the message types.
Is there a need for some meta information to help the test team?
What did Bluecore do?
Just some comments?
Eg 'connect' <bdaddr> clearly cannot list all possible bd addrs.
So there is some header file(s) with a list of supported commands

Expected output/documentation, grouped by domain:
message string
parameters, list of key/value types
description

Can we go one stage further and use the defintions to generate the C++ code itself in
the handler functions?
ie auto type casting?
There are 2 places where this may be useful.
1 is the domain owner, let's say the message emitter.
By autogenerating some part of the code we guarantee that the wire format is accurate.
2nd is the message receiver.
The basic autogenerated code would choose the correct variant-to-x function.
But is this useful?

What about some test tools? Eg apkipc-send. Here the tool needs to know the type in
order to correctly create the payload from the user params.
adkipc-send would take the command line message and look up in the database for the message type. But wait - why not assume that the values are strings and work with that for now? Are there any non-string values? Audio set volume is one. Mute set is bool too.



So what comes first, the payload description file or the doxygen?
Assuming that doxygen is the markup language for documentation.



---------------------------------

Am I redefining this or changing the original goal? Or simply thinking about ways of solving the problem in general?

---------------------------------
Code:
#define led_start_pattern "start_pattern"



**/

/*! @brief start pattern 


*/

/*! A test class */
class Afterdoc_Test
{
  public:
    /** An enum type. 
     *  The documentation block cannot be put after the enum! 
     */
    enum EnumType
    {
      int EVal1,     /**< enum value 1 */
      int EVal2      /**< enum value 2 */
    };
    void member();   //!< a member function.
    
  protected:
    int value;       /*!< an integer value */
};
